# -*- coding: utf-8 -*-
"""
/***************************************************************************
 YOLOPlugin
                                 A QGIS plugin
 Detect planes, airports, ships, helicopters and oil tankers from satellite imagery using a YOLO model.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-04-26
        git sha              : $Format:%H$
        copyright            : (C) 2025 by John doe
        email                : john.doe@email.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import datetime
import numpy as np
from qgis.core import (
    QgsSettings,
    QgsCategorizedSymbolRenderer,
    QgsFeature,
    QgsField,
    QgsFillSymbol,
    QgsGeometry,
    QgsMapRendererCustomPainterJob,
    QgsMapSettings,
    QgsPointXY,
    QgsProject,
    QgsRendererCategory,
    QgsVectorFileWriter,
    QgsVectorLayer,
    QgsMapLayer
)
from qgis.PyQt.QtCore import QMetaType, QSize
from qgis.PyQt.QtGui import QColor, QIcon, QImage, QPainter
from qgis.PyQt.QtWidgets import QAction
from ultralytics import YOLO

from .yolo_plugin_dialog import YOLOPluginDialog


class YOLOPlugin:
    def __init__(self, iface):
        self.selectedLayer = None
        self.dlg = None
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        self.first_start = None
        self.actions = []
        self.menu = "&YOLO Plugin"
        self.model_cache = {}
        self.last_selected_layer_name = None
        self.object_names = {
            "airport": "airport",
            "helicopter": "helicopter",
            "plane": "aircraft",
            "oiltank": "storage tank",
            "warship": "warship",
            "ship": "civil ship"
        }
        self.object_ids = {
            "airport": 0,
            "helicopter": 1,
            "plane": 3,
            "oiltank": 2,
            "warship": 1,
            "ship": 0
        }

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip:
            action.setStatusTip(status_tip)
        if whats_this:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)
        return action

    def initGui(self):
        icon_path = f"{self.plugin_dir}/icon.png"
        self.add_action(
            icon_path,
            text="Run YOLO detection",
            callback=self.run,
            parent=self.iface.mainWindow(),
        )
        self.first_start = True

    def unload(self):
        for action in self.actions:
            self.iface.removePluginMenu(self.menu, action)
            self.iface.removeToolBarIcon(action)

    def get_model(self, model_path):
        if model_path not in self.model_cache:
            if not os.path.exists(model_path):
                self.iface.messageBar().pushMessage("Error", f"Invalid model path: {model_path}", level=2, duration=4)
                return None
            self.model_cache[model_path] = YOLO(model_path)
        return self.model_cache[model_path]

    def run(self):
        if self.first_start:
            self.first_start = False
            self.dlg = YOLOPluginDialog()

        layers = QgsProject.instance().mapLayers().values()
        layer_names = [layer.name() for layer in layers]
        self.dlg.comboBox.clear()
        self.dlg.comboBox.addItems(layer_names)

        yolo_layer_names = [
            layer.name() for layer in layers 
            if layer.name().startswith("YOLO Detections")
        ]

        self.dlg.comboBox_export_layer.clear()
        self.dlg.comboBox_export_layer.addItems(yolo_layer_names)

        self.dlg.comboBox_target_layer.clear()
        vector_layers = [lyr.name() for lyr in layers if lyr.type() == QgsMapLayer.VectorLayer]
        self.dlg.comboBox_target_layer.addItems(vector_layers)

        self.dlg.comboBox_export_layer.setEnabled(self.dlg.checkBox_save_yolo.isChecked())
        try: 
            self.dlg.checkBox_save_yolo.toggled.disconnect()
        except TypeError:
            pass
        self.dlg.checkBox_save_yolo.toggled.connect(
            lambda checked: self.dlg.comboBox_export_layer.setEnabled(checked)
        )

        settings = QgsSettings()
        saved_layer_name = settings.value("YOLOPlugin/last_layer", "")
        if saved_layer_name in layer_names:
            index = layer_names.index(saved_layer_name)
            self.dlg.comboBox.setCurrentIndex(index)

        self.dlg.show()
        result = self.dlg.exec_()

        if result:
            current_tab = self.dlg.tabWidget.currentIndex()
            if current_tab == 0:
                selected_layer_name = self.dlg.comboBox.currentText()
                for layer in QgsProject.instance().mapLayers().values():
                    if layer.name() == selected_layer_name:
                        self.selectedLayer = layer
                        break

                if not self.selectedLayer:
                    return

                self.last_selected_layer_name = self.selectedLayer.name()
                settings.setValue("YOLOPlugin/last_layer", self.last_selected_layer_name)

                self.class_colors = self.dlg.get_class_colors()
                self.conf_threshold = self.dlg.get_confidence_threshold()
                self.is_new_mode = (self.dlg.get_save_option() == "new")

                self.models_to_run = [self.dlg.lineEdit_model1.text()]
                if self.dlg.get_run_multiple():
                    second_model = self.dlg.get_second_model_path()
                    if second_model == self.dlg.lineEdit_model1.text():
                        self.iface.messageBar().pushMessage("Error", "Models are the same.", level=2, duration=4)
                        return
                    if second_model:
                        self.models_to_run.append(second_model)

                self.detect_objects()

            elif current_tab == 1:
                self.handle_export()

    def handle_export(self):
        export_dir = self.dlg.lineEdit_export_dir.text()
        if not export_dir or not os.path.isdir(export_dir):
            self.iface.messageBar().pushMessage("Error", "Invalid export directory.", level=2, duration=4)
            return

        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        base_filename = f"yolo_export_{timestamp}"

        canvas = self.iface.mapCanvas()
        extent = canvas.extent()

        if self.dlg.checkBox_save_canvas.isChecked():
            img_path = os.path.join(export_dir, f"{base_filename}.png")
            settings = canvas.mapSettings()

            export_layer_name = self.dlg.comboBox_export_layer.currentText()
            clean_layers = []
            for layer in settings.layers():
                if layer.name() == export_layer_name:
                    continue
                if layer.name().startswith("YOLO Detections"):
                    continue
                clean_layers.append(layer)
            settings.setLayers(clean_layers)

            image = QImage(settings.outputSize(), QImage.Format_ARGB32_Premultiplied)
            image.fill(QColor(0, 0, 0, 0))

            painter = QPainter(image)
            job = QgsMapRendererCustomPainterJob(settings, painter)
            job.start()
            job.waitForFinished()
            painter.end()

            image.save(img_path)
            self.iface.messageBar().pushMessage("Export", f"Image saved: {base_filename}.png", level=0, duration=2)

        if self.dlg.checkBox_save_yolo.isChecked():
            selected_layer_name = self.dlg.comboBox_export_layer.currentText()
            target_layer = None
            for layer in QgsProject.instance().mapLayers().values():
                if layer.name() == selected_layer_name:
                    target_layer = layer
                    break

            if not target_layer:
                self.iface.messageBar().pushMessage("Error", "Selected export layer not found.", level=2, duration=4)
                return

            txt_path = os.path.join(export_dir, f"{base_filename}.txt")
            
            request = target_layer.getFeatures(extent)

            yolo_lines = []
            for feature in request:
                geom = feature.geometry()
                if not geom:
                    continue

                bbox = geom.boundingBox()
                if not extent.contains(bbox):
                    continue

                norm_x_min = (bbox.xMinimum() - extent.xMinimum()) / extent.width()
                norm_x_max = (bbox.xMaximum() - extent.xMinimum()) / extent.width()
                norm_y_min = (extent.yMaximum() - bbox.yMaximum()) / extent.height()
                norm_y_max = (extent.yMaximum() - bbox.yMinimum()) / extent.height()
                x_center = (norm_x_min + norm_x_max) / 2.0
                y_center = (norm_y_min + norm_y_max) / 2.0
                w = abs(norm_x_max - norm_x_min)
                h = abs(norm_y_max - norm_y_min)

                try:
                    class_id = self.object_ids.get(feature["class"], 0)
                except Exception:
                    class_id = 0

                yolo_lines.append(f"{class_id} {x_center:.6f} {y_center:.6f} {w:.6f} {h:.6f}")

            with open(txt_path, "w") as f:
                f.write("\n".join(yolo_lines))

            self.iface.messageBar().pushMessage("Export", f"YOLO labels saved: {base_filename}.txt", level=0, duration=2)

    def save_layer(self, layer):
        project_path = QgsProject.instance().fileName()
        if not project_path:
            self.iface.messageBar().pushMessage("Warning", "Project not saved. Please save the project to store the YOLO detection layer.", level=1, duration=3)
            return

        project_dir = os.path.dirname(project_path)
        base_name = layer.name().replace(" ", "_").lower()
        shp_path = os.path.join(project_dir, f"{base_name}.shp")

        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = "ESRI Shapefile"
        context = QgsProject.instance().transformContext()

        _, _, new_file, _ = QgsVectorFileWriter.writeAsVectorFormatV3(layer, shp_path, context, options)

        if new_file:
            new_layer = QgsVectorLayer(shp_path, layer.name(), "ogr")
            new_layer.setRenderer(layer.renderer().clone())
            QgsProject.instance().addMapLayer(new_layer)
            QgsProject.instance().removeMapLayer(layer.id())


    def get_or_create_layer(self):
        save_option = self.dlg.get_save_option()
        if save_option == "new":
            existing_numbers = []
            for lyr in QgsProject.instance().mapLayers().values():
                if lyr.name().startswith("YOLO Detections "):
                    try:
                        num = int(lyr.name().split(" ")[-1])
                        existing_numbers.append(num)
                    except ValueError:
                        pass

            next_num = 1 if not existing_numbers else max(existing_numbers) + 1
            layer_name = f"YOLO Detections {next_num}"
            layer = QgsVectorLayer("Polygon?crs=EPSG:3857", layer_name, "memory")

            pr = layer.dataProvider()
            pr.addAttributes([QgsField("class", QMetaType.Type.QString)])
            layer.updateFields()
            QgsProject.instance().addMapLayer(layer)
        else:
            target_name = self.dlg.get_target_layer_name()
            layer = None
            for lyr in QgsProject.instance().mapLayers().values():
                if lyr.name() == target_name:
                    layer = lyr
                    break

            if layer is None:
                self.iface.messageBar().pushMessage("Error", "Target layer not found, creating new.", level=2, duration=4)
                return self.get_or_create_layer()

            if layer.fields().indexFromName("class") == -1:
                if layer.isEditable() or layer.startEditing():
                    layer.addAttribute(QgsField("class", QMetaType.Type.QString))
                    layer.commitChanges()

        return layer

    def render_layer_to_image(self, layer):
        canvas = self.iface.mapCanvas()
        settings = QgsMapSettings()
        settings.setExtent(canvas.extent())
        settings.setOutputSize(QSize(canvas.width(), canvas.height()))
        settings.setDestinationCrs(canvas.mapSettings().destinationCrs())
        settings.setLayers([layer])

        image = QImage(canvas.width(), canvas.height(), QImage.Format_ARGB32_Premultiplied)
        image.fill(0)
        painter = QPainter(image)
        job = QgsMapRendererCustomPainterJob(settings, painter)
        job.start()
        job.waitForFinished()
        painter.end()
        return image

    def detect_objects(self):
        img = self.render_layer_to_image(self.selectedLayer)
        width, height = img.width(), img.height()
        ptr = img.bits()
        ptr.setsize(img.byteCount())
        img_array = np.array(ptr).reshape((height, width, 4))
        img_rgb = img_array[..., :3][..., ::-1]  # RGBA to BGR

        all_results = {}
        for m_path in self.models_to_run:
            model = self.get_model(m_path)
            if model:
                all_results[m_path] = model.predict(img_rgb)

        extent = self.iface.mapCanvas().extent()
        features = []
        detected_classes = set()

        for _, model_results in all_results.items():
            for r in model_results:
                for i, box in enumerate(r.boxes.xyxy):
                    if float(r.boxes.conf[i].item()) < self.conf_threshold:
                        continue
                    
                    x_min, y_min, x_max, y_max = box.tolist()
                    x1 = extent.xMinimum() + (x_min / width) * extent.width()
                    y1 = extent.yMaximum() - (y_min / height) * extent.height()
                    x2 = extent.xMinimum() + (x_max / width) * extent.width()
                    y2 = extent.yMaximum() - (y_max / height) * extent.height()

                    class_name = r.names[int(r.boxes.cls[i].item())]
                    detected_classes.add(class_name)

                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromPolygonXY([[QgsPointXY(x1,y1), QgsPointXY(x2,y1), QgsPointXY(x2,y2), QgsPointXY(x1,y2), QgsPointXY(x1,y1)]]))
                    feat.setAttributes([class_name])
                    features.append(feat)

        if not features:
            self.iface.messageBar().pushMessage("No objects detected", level=1, duration=2)
            return

        layer = self.get_or_create_layer()
        layer.dataProvider().addFeatures(features)
        layer.updateExtents()

        fill_alpha = int(255 * (1 - self.dlg.get_fill_transparency() / 100))
        outline_alpha = int(255 * (1 - self.dlg.get_outline_transparency() / 100))
        categories = []
        for name in detected_classes:
            ui_name = self.object_names.get(name)
            colors = self.class_colors.get(ui_name)

            if colors is None:
                f_c = QColor("white")
                o_c = QColor("black")
            else:
                f_c = QColor(colors.get("fill", "white"))
                o_c = QColor(colors.get("outline", "black"))
            
            sym = QgsFillSymbol.createSimple({
                "outline_width": "1.0",
                "color": f"{f_c.red()},{f_c.green()},{f_c.blue()},{fill_alpha if self.dlg.get_fill_enabled() else 0}",
                "outline_color": f"{o_c.red()},{o_c.green()},{o_c.blue()},{outline_alpha}",
            })
            categories.append(QgsRendererCategory(name, sym, ui_name if ui_name else name))

        if categories:
            if not self.is_new_mode:
                old_renderer = layer.renderer()
                if isinstance(old_renderer, QgsCategorizedSymbolRenderer):
                    for cat in old_renderer.categories():
                        if cat.value() not in [c.value() for c in categories]:
                            categories.append(cat)

        layer.setRenderer(QgsCategorizedSymbolRenderer("class", categories))
        layer.triggerRepaint()
        self.save_layer(layer)
        self.iface.messageBar().pushMessage("Success", f"Detected {len(features)} object(s).", level=0, duration=2)
