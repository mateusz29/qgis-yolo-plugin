# -*- coding: utf-8 -*-
"""
/***************************************************************************
 YOLOPlugin
                                 A QGIS plugin
 Detect planes, airports, ships, helicopters and oil tankers from satellite imagery using a YOLO model.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-04-26
        git sha              : $Format:%H$
        copyright            : (C) 2025 by John doe
        email                : john.doe@email.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

import numpy as np
from qgis.core import (
    QgsCategorizedSymbolRenderer,
    QgsFeature,
    QgsField,
    QgsFields,
    QgsFillSymbol,
    QgsGeometry,
    QgsPointXY,
    QgsProject,
    QgsRendererCategory,
    QgsVectorFileWriter,
    QgsVectorLayer,
)
from qgis.PyQt.QtCore import QMetaType
from qgis.PyQt.QtGui import QColor, QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from ultralytics import YOLO

from .yolo_plugin_dialog import YOLOPluginDialog


class YOLOPlugin:
    def __init__(self, iface):
        self.selectedLayer = None
        self.dlg = None
        self.model_path = None
        self.last_model_path = None
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        self.actions = []
        self.menu = "&YOLO Plugin"
        self.first_start = None
        self.model = None

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip:
            action.setStatusTip(status_tip)
        if whats_this:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)
        return action

    def initGui(self):
        icon_path = ":/plugins/yolo_plugin/icon.png"
        self.add_action(
            icon_path,
            text="Run YOLO detection",
            callback=self.run,
            parent=self.iface.mainWindow(),
        )
        self.first_start = True

    def unload(self):
        for action in self.actions:
            self.iface.removePluginMenu(self.menu, action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        if self.first_start:
            self.first_start = False
            self.dlg = YOLOPluginDialog()

            self.dlg.toolButton.clicked.connect(self.select_model_path)
            layers = QgsProject.instance().layerTreeRoot().children()
            self.dlg.comboBox.clear()
            self.dlg.comboBox.addItems([layer.name() for layer in layers])

        self.dlg.show()
        result = self.dlg.exec_()

        if result:
            self.model_path = self.dlg.lineEdit.text()
            selected_layer_index = self.dlg.comboBox.currentIndex()
            self.selectedLayer = QgsProject.instance().layerTreeRoot().children()[selected_layer_index].layer()

            if self.model is None or self.model_path != self.last_model_path:
                self.model = YOLO(self.model_path)
                self.last_model_path = self.model_path

            self.class_colors = self.dlg.get_class_colors()
            self.conf_threshold = self.dlg.get_confidence_threshold()
            self.detect_objects()

    def select_model_path(self):
        filename, _ = QFileDialog.getOpenFileName(self.dlg, "Select YOLO Model", "", "*.pt")
        if filename:
            self.dlg.lineEdit.setText(filename)

    def save_layer(self):
        old_layer = QgsProject.instance().mapLayersByName("YOLO Detections")[0]
        project_path = QgsProject.instance().fileName()
        if not project_path:
            self.iface.messageBar().pushMessage(
                "Warning",
                "Project not saved. Please save the project to store the YOLO detection layer.",
                level=1,
                duration=10,
            )
            return

        project_dir = os.path.dirname(project_path)
        shp_path = os.path.join(project_dir, "yolo_detections.shp")

        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = "ESRI Shapefile"
        context = QgsProject.instance().transformContext()

        _, _, new_file, _ = QgsVectorFileWriter.writeAsVectorFormatV3(old_layer, shp_path, context, options)

        if new_file:
            new_layer = QgsVectorLayer(shp_path, old_layer.name(), "ogr")
            new_layer.setRenderer(old_layer.renderer().clone())
            QgsProject.instance().addMapLayer(new_layer)
            QgsProject.instance().removeMapLayer(old_layer.id())

    def detect_objects(self):
        if not self.model_path or not os.path.exists(self.model_path):
            self.iface.messageBar().pushMessage("Error", "Model path is invalid", level=2, duration=5)
            return

        canvas = self.iface.mapCanvas()
        img = canvas.grab().toImage()

        width = img.width()
        height = img.height()
        ptr = img.bits()
        ptr.setsize(img.byteCount())

        img_array = np.array(ptr).reshape((height, width, 4))

        img_rgb = img_array[..., :3][..., ::-1]  # RGBA to BGR

        results = self.model.predict(img_rgb)

        extent = canvas.extent()

        features = []
        detected_classes = set()

        for r in results:
            for i, box in enumerate(r.boxes.xyxy):
                conf = float(r.boxes.conf[i].item())

                if conf < self.conf_threshold:
                    continue

                x_min, y_min, x_max, y_max = box.tolist()

                x1 = extent.xMinimum() + (x_min / width) * extent.width()
                y1 = extent.yMaximum() - (y_min / height) * extent.height()
                x2 = extent.xMinimum() + (x_max / width) * extent.width()
                y2 = extent.yMaximum() - (y_max / height) * extent.height()

                class_id = int(r.boxes.cls[i].item())
                class_name = r.names[class_id]
                detected_classes.add(class_name)

                feat = QgsFeature()
                feat.setGeometry(
                    QgsGeometry.fromPolygonXY(
                        [
                            [
                                QgsPointXY(x1, y1),
                                QgsPointXY(x2, y1),
                                QgsPointXY(x2, y2),
                                QgsPointXY(x1, y2),
                                QgsPointXY(x1, y1),
                            ]
                        ]
                    )
                )
                feat.setAttributes([class_name])
                features.append(feat)

        if not features:
            self.iface.messageBar().pushMessage("No objects detected", level=1, duration=3)
            return

        layer = None
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == "YOLO Detections":
                layer = lyr
                break

        if layer is None:
            layer = QgsVectorLayer("Polygon?crs=EPSG:3857", "YOLO Detections", "memory")
            pr = layer.dataProvider()
            fields = QgsFields()
            fields.append(QgsField("class", QMetaType.Type.QString))
            pr.addAttributes(fields)
            layer.updateFields()
            QgsProject.instance().addMapLayer(layer)
        else:
            pr = layer.dataProvider()

        pr.addFeatures(features)
        layer.updateExtents()

        fill_enabled = self.dlg.get_fill_enabled()
        transparency = self.dlg.get_transparency()
        alpha = int(255 * (1 - transparency / 100))

        categories = []
        for class_name in detected_classes:
            colors = self.class_colors.get(class_name)

            fill_color_obj = QColor(colors["fill"])
            outline_color_obj = QColor(colors["outline"])
            outline_color = f"{outline_color_obj.red()},{outline_color_obj.green()},{outline_color_obj.blue()}"

            if fill_enabled:
                fill_color = f"{fill_color_obj.red()},{fill_color_obj.green()},{fill_color_obj.blue()},{alpha}"
            else:
                fill_color = "0,0,0,0"

            symbol_params = {
                "outline_width": "1.0",
                "color": fill_color,
                "outline_color": outline_color,
            }

            symbol = QgsFillSymbol.createSimple(symbol_params)
            cat = QgsRendererCategory(class_name, symbol, class_name)
            categories.append(cat)

        if categories:
            old_renderer = layer.renderer()
            if isinstance(old_renderer, QgsCategorizedSymbolRenderer):
                for cat in old_renderer.categories():
                    if cat.value() not in [c.value() for c in categories]:
                        categories.append(cat)

            renderer = QgsCategorizedSymbolRenderer("class", categories)
            layer.setRenderer(renderer)

        layer.triggerRepaint()
        self.save_layer()
        self.iface.messageBar().pushMessage("Success", f"Detected {len(features)} object(s).", level=0, duration=5)
