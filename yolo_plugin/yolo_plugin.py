# -*- coding: utf-8 -*-
"""
/***************************************************************************
 YOLOPlugin
                                 A QGIS plugin
 Detect planes, airports, ships, helicopters and oil tankers from satellite imagery using a YOLO model.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-04-26
        git sha              : $Format:%H$
        copyright            : (C) 2025 by John doe
        email                : john.doe@email.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

import numpy as np
from qgis.core import (
    QgsCategorizedSymbolRenderer,
    QgsFeature,
    QgsField,
    QgsFields,
    QgsFillSymbol,
    QgsGeometry,
    QgsMapRendererCustomPainterJob,
    QgsMapSettings,
    QgsPointXY,
    QgsProject,
    QgsRendererCategory,
    QgsVectorFileWriter,
    QgsVectorLayer,
)
from qgis.PyQt.QtCore import QMetaType, QSettings, QSize
from qgis.PyQt.QtGui import QColor, QIcon, QImage, QPainter
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from ultralytics import YOLO

from .yolo_plugin_dialog import YOLOPluginDialog


class YOLOPlugin:
    def __init__(self, iface):
        self.selectedLayer = None
        self.dlg = None
        self.model_path = None
        self.last_model_path = None
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        self.first_start = None
        self.actions = []
        self.menu = "&YOLO Plugin"
        self.model = None
        self.last_selected_layer_name = None

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip:
            action.setStatusTip(status_tip)
        if whats_this:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)
        return action

    def initGui(self):
        icon_path = f"{self.plugin_dir}/icon.png"
        self.add_action(
            icon_path,
            text="Run YOLO detection",
            callback=self.run,
            parent=self.iface.mainWindow(),
        )
        self.first_start = True

    def unload(self):
        for action in self.actions:
            self.iface.removePluginMenu(self.menu, action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        if self.first_start:
            self.first_start = False
            self.dlg = YOLOPluginDialog()
            self.dlg.toolButton.clicked.connect(self.select_model_path)

        layers = QgsProject.instance().layerTreeRoot().children()
        layer_names = [layer.name() for layer in layers]
        self.dlg.comboBox.clear()
        self.dlg.comboBox.addItems(layer_names)

        if self.last_selected_layer_name and self.last_selected_layer_name in layer_names:
            index = layer_names.index(self.last_selected_layer_name)
            self.dlg.comboBox.setCurrentIndex(index)

        self.dlg.show()
        result = self.dlg.exec_()

        if result:
            self.model_path = self.dlg.lineEdit.text()
            selected_layer_index = self.dlg.comboBox.currentIndex()
            self.selectedLayer = QgsProject.instance().layerTreeRoot().children()[selected_layer_index].layer()
            self.last_selected_layer_name = self.selectedLayer.name()

            if self.model is None or self.model_path != self.last_model_path:
                self.model = YOLO(self.model_path)
                self.last_model_path = self.model_path

            self.class_colors = self.dlg.get_class_colors()
            self.conf_threshold = self.dlg.get_confidence_threshold()
            self.create_new_layer = self.dlg.get_create_new_layer()
            self.detect_objects()

    def select_model_path(self):
        filename, _ = QFileDialog.getOpenFileName(self.dlg, "Select YOLO Model", "", "*.pt")
        if filename:
            self.dlg.lineEdit.setText(filename)
            QSettings().setValue("YOLOPlugin/model_path", filename)

    def save_layer(self, layer):
        project_path = QgsProject.instance().fileName()
        if not project_path:
            self.iface.messageBar().pushMessage(
                "Warning",
                "Project not saved. Please save the project to store the YOLO detection layer.",
                level=1,
                duration=10,
            )
            return

        project_dir = os.path.dirname(project_path)
        base_name = layer.name().replace(" ", "_").lower()
        shp_path = os.path.join(project_dir, f"{base_name}.shp")

        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = "ESRI Shapefile"
        context = QgsProject.instance().transformContext()

        _, _, new_file, _ = QgsVectorFileWriter.writeAsVectorFormatV3(layer, shp_path, context, options)

        if new_file:
            new_layer = QgsVectorLayer(shp_path, layer.name(), "ogr")
            new_layer.setRenderer(layer.renderer().clone())
            QgsProject.instance().addMapLayer(new_layer)
            QgsProject.instance().removeMapLayer(layer.id())

    def get_or_create_layer(self):
        if self.create_new_layer:
            existing_numbers = []
            for lyr in QgsProject.instance().mapLayers().values():
                if lyr.name().startswith("YOLO Detections "):
                    try:
                        num = int(lyr.name().split(" ")[-1])
                        existing_numbers.append(num)
                    except ValueError:
                        pass
            next_num = 1 if not existing_numbers else max(existing_numbers) + 1
            layer_name = f"YOLO Detections {next_num}"

            layer = QgsVectorLayer("Polygon?crs=EPSG:3857", layer_name, "memory")
            pr = layer.dataProvider()
            fields = QgsFields()
            fields.append(QgsField("class", QMetaType.Type.QString))
            pr.addAttributes(fields)
            layer.updateFields()
            QgsProject.instance().addMapLayer(layer)
            return layer
        else:
            layer = None
            for lyr in QgsProject.instance().mapLayers().values():
                if lyr.name() == "YOLO Detections 1":
                    layer = lyr
                    break

            if layer is None:
                layer = QgsVectorLayer("Polygon?crs=EPSG:3857", "YOLO Detections 1", "memory")
                pr = layer.dataProvider()
                fields = QgsFields()
                fields.append(QgsField("class", QMetaType.Type.QString))
                pr.addAttributes(fields)
                layer.updateFields()
                QgsProject.instance().addMapLayer(layer)

            return layer

    def render_layer_to_image(self, layer):
        canvas = self.iface.mapCanvas()
        extent = canvas.extent()

        settings = QgsMapSettings()
        settings.setExtent(extent)
        settings.setOutputSize(QSize(canvas.width(), canvas.height()))
        settings.setDestinationCrs(canvas.mapSettings().destinationCrs())
        settings.setLayers([layer])

        image = QImage(canvas.width(), canvas.height(), QImage.Format_ARGB32_Premultiplied)
        image.fill(0)

        painter = QPainter(image)
        job = QgsMapRendererCustomPainterJob(settings, painter)
        job.start()
        job.waitForFinished()
        painter.end()

        return image

    def detect_objects(self):
        if not self.model_path or not os.path.exists(self.model_path):
            self.iface.messageBar().pushMessage("Error", "Model path is invalid", level=2, duration=5)
            return

        img = self.render_layer_to_image(self.selectedLayer)

        width = img.width()
        height = img.height()
        ptr = img.bits()
        ptr.setsize(img.byteCount())

        img_array = np.array(ptr).reshape((height, width, 4))

        img_rgb = img_array[..., :3][..., ::-1]  # RGBA to BGR

        results = self.model.predict(img_rgb)

        extent = self.iface.mapCanvas().extent()

        features = []
        detected_classes = set()

        for r in results:
            for i, box in enumerate(r.boxes.xyxy):
                conf = float(r.boxes.conf[i].item())

                if conf < self.conf_threshold:
                    continue

                x_min, y_min, x_max, y_max = box.tolist()

                x1 = extent.xMinimum() + (x_min / width) * extent.width()
                y1 = extent.yMaximum() - (y_min / height) * extent.height()
                x2 = extent.xMinimum() + (x_max / width) * extent.width()
                y2 = extent.yMaximum() - (y_max / height) * extent.height()

                class_id = int(r.boxes.cls[i].item())
                class_name = r.names[class_id]
                detected_classes.add(class_name)

                feat = QgsFeature()
                feat.setGeometry(
                    QgsGeometry.fromPolygonXY(
                        [
                            [
                                QgsPointXY(x1, y1),
                                QgsPointXY(x2, y1),
                                QgsPointXY(x2, y2),
                                QgsPointXY(x1, y2),
                                QgsPointXY(x1, y1),
                            ]
                        ]
                    )
                )
                feat.setAttributes([class_name])
                features.append(feat)

        if not features:
            self.iface.messageBar().pushMessage("No objects detected", level=1, duration=3)
            return

        layer = self.get_or_create_layer()
        pr = layer.dataProvider()

        pr.addFeatures(features)
        layer.updateExtents()

        fill_enabled = self.dlg.get_fill_enabled()
        fill_transparency = self.dlg.get_fill_transparency()
        outline_transparency = self.dlg.get_outline_transparency()
        fill_alpha = int(255 * (1 - fill_transparency / 100))
        outline_alpha = int(255 * (1 - outline_transparency / 100))

        categories = []
        for class_name in detected_classes:
            colors = self.class_colors.get(class_name)

            fill_color_obj = QColor(colors["fill"])
            outline_color_obj = QColor(colors["outline"])
            outline_color = (
                f"{outline_color_obj.red()},{outline_color_obj.green()},{outline_color_obj.blue()},{outline_alpha}"
            )

            if fill_enabled:
                fill_color = f"{fill_color_obj.red()},{fill_color_obj.green()},{fill_color_obj.blue()},{fill_alpha}"
            else:
                fill_color = "0,0,0,0"

            symbol_params = {
                "outline_width": "1.0",
                "color": fill_color,
                "outline_color": outline_color,
            }

            symbol = QgsFillSymbol.createSimple(symbol_params)
            cat = QgsRendererCategory(class_name, symbol, class_name)
            categories.append(cat)

        if categories:
            if not self.create_new_layer:
                old_renderer = layer.renderer()
                if isinstance(old_renderer, QgsCategorizedSymbolRenderer):
                    for cat in old_renderer.categories():
                        if cat.value() not in [c.value() for c in categories]:
                            categories.append(cat)

            renderer = QgsCategorizedSymbolRenderer("class", categories)
            layer.setRenderer(renderer)

        layer.triggerRepaint()
        self.save_layer(layer)
        self.iface.messageBar().pushMessage("Success", f"Detected {len(features)} object(s).", level=0, duration=5)
