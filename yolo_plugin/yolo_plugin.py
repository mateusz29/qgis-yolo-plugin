# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Yolo_plugin
                               
 QGIS plugin: YOLO-based detection of aircraft, airports, ships, helicopters, and storage tanks in satellite imagery.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-04-26
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Marcin Ciecholewski
        email                : marcin.ciecholewski@pg.edu.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import datetime
import numpy as np
from qgis.core import (
    QgsSettings,
    QgsCategorizedSymbolRenderer,
    QgsFeature,
    QgsField,
    QgsFillSymbol,
    QgsGeometry,
    QgsMapRendererCustomPainterJob,
    QgsMapSettings,
    QgsPointXY,
    QgsProject,
    QgsRendererCategory,
    QgsVectorFileWriter,
    QgsVectorLayer,
    QgsMapLayer,
    QgsRectangle
)
from qgis.PyQt.QtCore import QMetaType, QSize
from qgis.PyQt.QtGui import QColor, QIcon, QImage, QPainter
from qgis.PyQt.QtWidgets import QAction
from ultralytics import YOLO

from .yolo_plugin_dialog import YOLOPluginDialog


class YOLOPlugin:
    """Main plugin class integrating YOLO detection into QGIS.

    This class manages the plugin lifecycle, GUI actions, model loading,
    object detection on a selected vector layer, and exporting results.
    """
    def __init__(self, iface):
        self.selectedLayer = None
        self.dlg = None
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        self.first_start = None
        self.actions = []
        self.menu = "&YOLO Plugin"
        self.model_cache = {}
        self.last_selected_layer_name = None
        self.object_names = {
            "airport": "airport",
            "helicopter": "helicopter",
            "plane": "aircraft",
            "oiltank": "storage tank",
            "warship": "warship",
            "ship": "civilian ship"
        }
        self.object_ids = {
            "airport": 0,
            "helicopter": 1,
            "plane": 3,
            "oiltank": 2,
            "warship": 1,
            "ship": 0
        }

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip:
            action.setStatusTip(status_tip)
        if whats_this:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)
        return action

    def initGui(self):
        icon_path = f"{self.plugin_dir}/icon.png"
        self.add_action(
            icon_path,
            text="Run YOLO detection",
            callback=self.run,
            parent=self.iface.mainWindow(),
        )
        self.first_start = True

    def unload(self):
        """Remove plugin actions from QGIS UI when unloading the plugin."""
        for action in self.actions:
            self.iface.removePluginMenu(self.menu, action)
            self.iface.removeToolBarIcon(action)

    def get_model(self, model_path):
        """Load and cache a YOLO model from disk.

        If the path is invalid, display an error message and return None.
        Caching avoids reloading the same model multiple times.
        """
        if model_path not in self.model_cache:
            if not os.path.exists(model_path):
                self.iface.messageBar().pushMessage("Error", f"Invalid model path: {model_path}", level=2, duration=4)
                return None
            self.model_cache[model_path] = YOLO(model_path)
        return self.model_cache[model_path]

    def run(self):
        """Show the plugin dialog and dispatch actions based on user input.

        Prepares layer lists, restores last-used settings, and either
        runs detection or performs export depending on the selected tab.
        """
        if self.first_start:
            self.first_start = False
            self.dlg = YOLOPluginDialog()

        layers = QgsProject.instance().mapLayers().values()
        layer_names = [layer.name() for layer in layers]
        self.dlg.comboBox.clear()
        self.dlg.comboBox.addItems(layer_names)

        yolo_vector_layers = [
            layer.name() for layer in layers 
            if layer.type() == QgsMapLayer.VectorLayer and layer.name().startswith("YOLO Detections")
        ]

        self.dlg.comboBox_merge_from.clear()
        self.dlg.comboBox_merge_from.addItems(yolo_vector_layers)
        self.dlg.comboBox_merge_to.clear()
        self.dlg.comboBox_merge_to.addItems(yolo_vector_layers)

        self.dlg.comboBox_export_layer.clear()
        self.dlg.comboBox_export_layer.addItems(yolo_vector_layers)

        has_existing = len(yolo_vector_layers) > 0
        self.dlg.radio_append_layer.setEnabled(has_existing)

        if not has_existing:
            self.dlg.radio_new_layer.setChecked(True)

        self.dlg.comboBox_target_layer.clear()
        vector_layers = [lyr.name() for lyr in layers if lyr.type() == QgsMapLayer.VectorLayer]
        self.dlg.comboBox_target_layer.addItems(vector_layers)

        self.dlg.comboBox_export_layer.setEnabled(self.dlg.checkBox_save_yolo.isChecked())
        try: 
            self.dlg.checkBox_save_yolo.toggled.disconnect()
        except TypeError:
            pass
        self.dlg.checkBox_save_yolo.toggled.connect(
            lambda checked: self.dlg.comboBox_export_layer.setEnabled(checked)
        )

        settings = QgsSettings()
        saved_layer_name = settings.value("YOLOPlugin/last_layer", "")
        if saved_layer_name in layer_names:
            index = layer_names.index(saved_layer_name)
            self.dlg.comboBox.setCurrentIndex(index)

        self.dlg.show()
        result = self.dlg.exec_()

        if result:
            current_tab = self.dlg.tabWidget.currentIndex()
            if current_tab == 0:
                selected_layer_name = self.dlg.comboBox.currentText()
                for layer in QgsProject.instance().mapLayers().values():
                    if layer.name() == selected_layer_name:
                        self.selectedLayer = layer
                        break

                if not self.selectedLayer:
                    return

                self.last_selected_layer_name = self.selectedLayer.name()
                settings.setValue("YOLOPlugin/last_layer", self.last_selected_layer_name)

                self.class_colors = self.dlg.get_class_colors()
                self.conf_threshold = self.dlg.get_confidence_threshold()
                self.is_new_mode = (self.dlg.get_save_option() == "new")

                # Collect model paths (support running two models sequentially)
                self.models_to_run = [self.dlg.lineEdit_model1.text()]
                if self.dlg.get_run_multiple():
                    second_model = self.dlg.get_second_model_path()
                    if second_model == self.dlg.lineEdit_model1.text():
                        self.iface.messageBar().pushMessage("Error", "Models are the same.", level=2, duration=4)
                        return
                    if second_model:
                        self.models_to_run.append(second_model)

                self.detect_objects()
            elif current_tab == 1:
                self.handle_export()
            elif current_tab == 2:
                self.handle_merge()
            elif current_tab == 3:
                self.handle_tiling()

    def handle_export(self):
        """Export current map canvas image and/or YOLO detection labels.

        Validates the export directory, optionally saves a PNG of the canvas,
        and writes YOLO-format label files from a chosen detection layer.
        """
        export_dir = self.dlg.lineEdit_export_dir.text()
        if not export_dir or not os.path.isdir(export_dir):
            self.iface.messageBar().pushMessage("Error", "Invalid export directory.", level=2, duration=4)
            return

        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        base_filename = f"yolo_export_{timestamp}"

        canvas = self.iface.mapCanvas()
        extent = canvas.extent()

        if self.dlg.checkBox_save_canvas.isChecked():
            img_path = os.path.join(export_dir, f"{base_filename}.png")
            settings = canvas.mapSettings()

            export_layer_name = self.dlg.comboBox_export_layer.currentText()
            clean_layers = []
            for layer in settings.layers():
                if layer.name() == export_layer_name:
                    continue
                if layer.name().startswith("YOLO Detections"):
                    continue
                clean_layers.append(layer)
            settings.setLayers(clean_layers)

            image = QImage(settings.outputSize(), QImage.Format_ARGB32_Premultiplied)
            image.fill(QColor(0, 0, 0, 0))

            painter = QPainter(image)
            job = QgsMapRendererCustomPainterJob(settings, painter)
            job.start()
            job.waitForFinished()
            painter.end()

            image.save(img_path)
            self.iface.messageBar().pushMessage("Export", f"Image saved: {base_filename}.png", level=0, duration=2)

        # If user requested saving YOLO labels, write a .txt file with normalized bboxes
        if self.dlg.checkBox_save_yolo.isChecked():
            selected_layer_name = self.dlg.comboBox_export_layer.currentText()
            target_layer = None
            for layer in QgsProject.instance().mapLayers().values():
                if layer.name() == selected_layer_name:
                    target_layer = layer
                    break

            if not target_layer:
                self.iface.messageBar().pushMessage("Error", "Selected export layer not found.", level=2, duration=4)
                return

            txt_path = os.path.join(export_dir, f"{base_filename}.txt")
            
            request = target_layer.getFeatures(extent)

            yolo_lines = []
            for feature in request:
                geom = feature.geometry()
                if not geom:
                    continue

                bbox = geom.boundingBox()
                if not extent.contains(bbox):
                    continue

                norm_x_min = (bbox.xMinimum() - extent.xMinimum()) / extent.width()
                norm_x_max = (bbox.xMaximum() - extent.xMinimum()) / extent.width()
                norm_y_min = (extent.yMaximum() - bbox.yMaximum()) / extent.height()
                norm_y_max = (extent.yMaximum() - bbox.yMinimum()) / extent.height()
                x_center = (norm_x_min + norm_x_max) / 2.0
                y_center = (norm_y_min + norm_y_max) / 2.0
                w = abs(norm_x_max - norm_x_min)
                h = abs(norm_y_max - norm_y_min)

                try:
                    class_id = self.object_ids.get(feature["class"], 0)
                except Exception:
                    class_id = 0

                yolo_lines.append(f"{class_id} {x_center:.6f} {y_center:.6f} {w:.6f} {h:.6f}")

            with open(txt_path, "w") as f:
                f.write("\n".join(yolo_lines))

            self.iface.messageBar().pushMessage("Export", f"YOLO labels saved: {base_filename}.txt", level=0, duration=2)

    def handle_merge(self):
        """Copies all features from the source layer to the destination layer."""
        from_name, to_name = self.dlg.get_merge_layers()
        
        if from_name == to_name:
            self.iface.messageBar().pushMessage("Error", "Source and destination layers must be different.", level=2)
            return

        layers = QgsProject.instance().mapLayers().values()
        source_layer = next((layer for layer in layers if layer.name() == from_name), None)
        dest_layer = next((layer for layer in layers if layer.name() == to_name), None)

        if not source_layer or not dest_layer:
            return

        # Add fields from source that don't exist in destination
        src_fields = source_layer.fields()
        dst_fields = dest_layer.fields()
        missing_fields = [f for f in src_fields if dst_fields.indexFromName(f.name()) == -1]

        if missing_fields:
            dest_layer.dataProvider().addAttributes(missing_fields)
            dest_layer.updateFields()
            dst_fields = dest_layer.fields()

        # Copy features
        new_features = []
        for feat in source_layer.getFeatures():
            new_feat = QgsFeature(dst_fields)
            new_feat.setGeometry(feat.geometry())
            
            for field in src_fields:
                attr_val = feat[field.name()]
                new_feat.setAttribute(field.name(), attr_val)
                
            new_features.append(new_feat)

        if new_features:
            dest_layer.startEditing()
            success = dest_layer.addFeatures(new_features)
            if success:
                dest_layer.commitChanges()
                src_renderer = source_layer.renderer()
                dst_renderer = dest_layer.renderer()

                if isinstance(src_renderer, QgsCategorizedSymbolRenderer) and isinstance(dst_renderer, QgsCategorizedSymbolRenderer):
                    existing_dst_values = [c.value() for c in dst_renderer.categories()]
                    changed = False

                    for src_cat in src_renderer.categories():
                        if src_cat.value() not in existing_dst_values:
                            new_cat = QgsRendererCategory(
                                src_cat.value(), 
                                src_cat.symbol().clone(), 
                                src_cat.label(),
                                src_cat.renderState()
                            )
                            dst_renderer.addCategory(new_cat)
                            changed = True

                    if changed:
                        dest_layer.triggerRepaint()
                        self.iface.layerTreeView().refreshLayerSymbology(dest_layer.id())

                self.iface.messageBar().pushMessage("Success", f"Merged {len(new_features)} features into {to_name}", level=0, duration=2)
            else:
                dest_layer.rollBack()
                self.iface.messageBar().pushMessage("Error", "Failed to add features to destination layer.", level=2, duration=4)

    def handle_tiling(self):
        """Split the current map canvas into multiple image tiles.

        Calculates a grid based on user-defined pixel dimensions, renders each 
        cell of the grid to a separate PNG image, and saves them to the 
        specified directory. Leftover space at the right and bottom edges 
        is ignored.
        """
        p = self.dlg.get_tiling_params()
        if not p["dir"] or not os.path.isdir(p["dir"]):
            self.iface.messageBar().pushMessage("Error", "Invalid tiling export path", level=2, duration=4)
            return

        canvas = self.iface.mapCanvas()
        settings = QgsMapSettings(canvas.mapSettings())
        clean_layers = []
        for layer in settings.layers():
            if layer.name().startswith("YOLO Detections"):
                continue
            clean_layers.append(layer)
        settings.setLayers(clean_layers)

        full_extent = settings.extent()
        canvas_size = settings.outputSize()

        px_w_geo = full_extent.width() / canvas_size.width()
        px_h_geo = full_extent.height() / canvas_size.height()

        t_w = p["width"]
        t_h = p["height"]

        cols = canvas_size.width() // t_w
        rows = canvas_size.height() // t_h
        total_tiles = cols * rows

        if total_tiles == 0:
            self.iface.messageBar().pushMessage("Error", "Tile size is larger than current canvas.", level=2, duration=4)
            return

        count = 0
        for r in range(rows):
            for c in range(cols):
                px_x = c * t_w
                px_y = r * t_h

                x_min = full_extent.xMinimum() + (px_x * px_w_geo)
                y_max = full_extent.yMaximum() - (px_y * px_h_geo)
                x_max = x_min + (t_w * px_w_geo)
                y_min = y_max - (t_h * px_h_geo)

                tile_extent = QgsRectangle(x_min, y_min, x_max, y_max)

                settings.setExtent(tile_extent)
                settings.setOutputSize(QSize(t_w, t_h))

                img = QImage(QSize(t_w, t_h), QImage.Format_ARGB32_Premultiplied)
                img.fill(QColor(0, 0, 0, 0))

                painter = QPainter(img)
                job = QgsMapRendererCustomPainterJob(settings, painter)
                job.start()
                job.waitForFinished()
                painter.end()

                filename = f"tile_{t_w}_{count}.png"
                img.save(os.path.join(p["dir"], filename))

                count += 1

        self.iface.messageBar().pushMessage("Success", f"Generated {count} tiles.", level=0, duration=2)

    def save_layer(self, layer):
        """Persist a memory layer to a shapefile in the project directory.

        If the project has not been saved, prompt the user to save first.
        """
        project_path = QgsProject.instance().fileName()
        if not project_path:
            self.iface.messageBar().pushMessage("Warning", "Project not saved. Please save the project to store the YOLO detection layer.", level=1, duration=3)
            return

        project_dir = os.path.dirname(project_path)
        base_name = layer.name().replace(" ", "_").lower()
        shp_path = os.path.join(project_dir, f"{base_name}.shp")

        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = "ESRI Shapefile"
        context = QgsProject.instance().transformContext()

        _, _, new_file, _ = QgsVectorFileWriter.writeAsVectorFormatV3(layer, shp_path, context, options)

        if new_file:
            new_layer = QgsVectorLayer(shp_path, layer.name(), "ogr")
            new_layer.setRenderer(layer.renderer().clone())
            QgsProject.instance().addMapLayer(new_layer)
            QgsProject.instance().removeMapLayer(layer.id())

    def get_or_create_layer(self):
        """Return an existing target layer or create a new YOLO Detections memory layer.

        If the user chose 'append', the existing layer is returned (and
        a missing 'class' attribute is added). If 'new' is chosen a
        uniquely numbered memory layer is created and added to the project.
        """
        save_option = self.dlg.get_save_option()
        if save_option == "new":
            existing_numbers = []
            for lyr in QgsProject.instance().mapLayers().values():
                if lyr.name().startswith("YOLO Detections "):
                    try:
                        num = int(lyr.name().split(" ")[-1])
                        existing_numbers.append(num)
                    except ValueError:
                        pass

            next_num = 1 if not existing_numbers else max(existing_numbers) + 1
            layer_name = f"YOLO Detections {next_num}"
            layer = QgsVectorLayer("Polygon?crs=EPSG:3857", layer_name, "memory")

            pr = layer.dataProvider()
            pr.addAttributes([QgsField("class", QMetaType.Type.QString)])
            layer.updateFields()
            QgsProject.instance().addMapLayer(layer)
        else:
            target_name = self.dlg.get_target_layer_name()
            layer = None
            for lyr in QgsProject.instance().mapLayers().values():
                if lyr.name() == target_name:
                    layer = lyr
                    break

            if layer is None:
                self.iface.messageBar().pushMessage("Error", "Target layer not found, creating new.", level=2, duration=4)
                return self.get_or_create_layer()

            if layer.fields().indexFromName("class") == -1:
                if layer.isEditable() or layer.startEditing():
                    layer.addAttribute(QgsField("class", QMetaType.Type.QString))
                    layer.commitChanges()

        return layer

    def render_layer_to_image(self, layer):
        """Render a vector layer to an off-screen image using current canvas settings.

        Returns a QImage with the rendered layer contents sized to the map canvas.
        """
        canvas = self.iface.mapCanvas()
        settings = QgsMapSettings()
        settings.setExtent(canvas.extent())
        settings.setOutputSize(QSize(canvas.width(), canvas.height()))
        settings.setDestinationCrs(canvas.mapSettings().destinationCrs())
        settings.setLayers([layer])

        image = QImage(canvas.width(), canvas.height(), QImage.Format_ARGB32_Premultiplied)
        image.fill(0)
        painter = QPainter(image)
        job = QgsMapRendererCustomPainterJob(settings, painter)
        job.start()
        job.waitForFinished()
        painter.end()
        return image

    def detect_objects(self):
        """Run YOLO inference on the rendered image and create polygon features.

        The rendered image is converted to a NumPy array, fed to the model(s),
        and detection boxes are converted back to project coordinates. Results
        are added to the target vector layer and styled according to dialog settings.
        """
        img = self.render_layer_to_image(self.selectedLayer)
        width, height = img.width(), img.height()
        ptr = img.bits()
        ptr.setsize(img.byteCount())
        img_array = np.array(ptr).reshape((height, width, 4))
        img_rgb = img_array[..., :3][..., ::-1]  # RGBA to BGR

        all_results = {}
        for m_path in self.models_to_run:
            model = self.get_model(m_path)
            if model:
                all_results[m_path] = model.predict(img_rgb)

        extent = self.iface.mapCanvas().extent()
        features = []
        detected_classes = set()

        for _, model_results in all_results.items():
            for r in model_results:
                for i, box in enumerate(r.boxes.xyxy):
                    if float(r.boxes.conf[i].item()) < self.conf_threshold:
                        continue
                    
                    x_min, y_min, x_max, y_max = box.tolist()
                    x1 = extent.xMinimum() + (x_min / width) * extent.width()
                    y1 = extent.yMaximum() - (y_min / height) * extent.height()
                    x2 = extent.xMinimum() + (x_max / width) * extent.width()
                    y2 = extent.yMaximum() - (y_max / height) * extent.height()

                    raw_name = r.names[int(r.boxes.cls[i].item())]
                    class_name = self.object_names.get(raw_name)
                    detected_classes.add(class_name)

                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromPolygonXY([[QgsPointXY(x1,y1), QgsPointXY(x2,y1), QgsPointXY(x2,y2), QgsPointXY(x1,y2), QgsPointXY(x1,y1)]]))
                    feat.setAttributes([class_name])
                    features.append(feat)

        if not features:
            self.iface.messageBar().pushMessage("No objects detected", level=1, duration=2)
            return

        layer = self.get_or_create_layer()
        layer.dataProvider().addFeatures(features)
        layer.updateExtents()

        fill_alpha = int(255 * (1 - self.dlg.get_fill_transparency() / 100))
        outline_alpha = int(255 * (1 - self.dlg.get_outline_transparency() / 100))
        categories = []
        for name in detected_classes:
            colors = self.class_colors.get(name)

            if colors is None:
                f_c = QColor("white")
                o_c = QColor("black")
            else:
                f_c = QColor(colors.get("fill", "white"))
                o_c = QColor(colors.get("outline", "black"))
            
            sym = QgsFillSymbol.createSimple({
                "outline_width": "1.0",
                "color": f"{f_c.red()},{f_c.green()},{f_c.blue()},{fill_alpha if self.dlg.get_fill_enabled() else 0}",
                "outline_color": f"{o_c.red()},{o_c.green()},{o_c.blue()},{outline_alpha}",
            })
            categories.append(QgsRendererCategory(name, sym, name))

        if categories:
            if not self.is_new_mode:
                old_renderer = layer.renderer()
                if isinstance(old_renderer, QgsCategorizedSymbolRenderer):
                    for cat in old_renderer.categories():
                        if cat.value() not in [c.value() for c in categories]:
                            categories.append(cat)

        layer.setRenderer(QgsCategorizedSymbolRenderer("class", categories))
        layer.triggerRepaint()
        self.save_layer(layer)
        self.iface.messageBar().pushMessage("Success", f"Detected {len(features)} object(s).", level=0, duration=2)
